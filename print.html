<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Actix 用户指南中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Actix——Rust 语言的 actor 框架">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <noscript>
            <style type="text/css">
                .javascript-only {
                    display: none;
                }
            </style>
        </noscript>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="sec-0-quick-start.html">Actix 快速入门</a></li><li><a href="sec-1-getting-started.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li><a href="sec-2-actor.html"><strong aria-hidden="true">2.</strong> 参与者</a></li><li><a href="sec-3-address.html"><strong aria-hidden="true">3.</strong> 地址</a></li><li><a href="sec-4-context.html"><strong aria-hidden="true">4.</strong> 上下文</a></li><li><a href="sec-5-arbiter.html"><strong aria-hidden="true">5.</strong> Arbiter</a></li><li><a href="sec-6-sync-arbiter.html"><strong aria-hidden="true">6.</strong> SyncArbiter</a></li><li><a href="sec-7-stream.html"><strong aria-hidden="true">7.</strong> Stream</a></li><li><a href="sec-8-io-helpers.html"><strong aria-hidden="true">8.</strong> IO 助手</a></li><li><a href="sec-9-supervisor.html"><strong aria-hidden="true">9.</strong> Supervisor</a></li><li><a href="sec-10-registry.html"><strong aria-hidden="true">10.</strong> Registry</a></li><li><a href="sec-11-helper-actors.html"><strong aria-hidden="true">11.</strong> 助手参与者</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons javascript-only">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Actix 用户指南中文版</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </div>
                <div id="searchresults-outer" class="searchresults-outer">
                    <div class="searchresults-header" id="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#a快速开始" id="a快速开始"><h1>快速开始</h1></a>
<p>在开始编写 actix 应用程序之前需要先安装某一版本的 Rust。
建议使用 rustup 来安装或配置版本。</p>
<a class="header" href="print.html#a安装-rust" id="a安装-rust"><h2>安装 Rust</h2></a>
<p>在开始之前，我们需要使用 <a href="https://rustup.rs/">rustup</a> 安装程序来安装 Rust：</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>如果已经安装过 rustup，请运行这个命令来确保拥有最新版本的 Rust：</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p>actix 框架需要 Rust 1.40.0 及更高版本。</p>
<a class="header" href="print.html#a运行示例" id="a运行示例"><h2>运行示例</h2></a>
<p>开始试验 actix 最快的方法是克隆 actix 版本库<!--
-->并运行 examples/ 目录中所包含的示例。以下这组<!--
-->命令会运行 <code>ping</code> 示例：</p>
<pre><code class="language-bash">git clone https://github.com/actix/actix
cargo run --example ping
</code></pre>
<p>更多示例请查看 <a href="https://github.com/actix/actix/tree/master/examples">examples/</a> 目录。</p>
<a class="header" href="print.html#a入门" id="a入门"><h1>入门</h1></a>
<p>让我们来创建并运行第一个 actix 应用程序。我们会创建一个新的依赖于 actix 的 Cargo
项目，然后运行该应用程序。</p>
<p>在上一节中，我们已经安装了所需的 rust 版本。现在来创建新的 cargo 项目。</p>
<a class="header" href="print.html#ping-参与者" id="ping-参与者"><h2>Ping 参与者</h2></a>
<p>我们来写第一个 actix 应用程序吧！首先创建一个新的基于二进制的
Cargo 项目并切换到新目录中：</p>
<pre><code class="language-bash">cargo new actor-ping
cd actor-ping
</code></pre>
<p>现在，将 actix 添加为项目的依赖，即确保 Cargo.toml
中包含以下内容：</p>
<pre><code class="language-toml">[dependencies]
actix = &quot;0.10.0-alpha.3&quot;
actix-rt = &quot;1.1&quot; # &lt;-- Runtime for actix
</code></pre>
<p>我们来创建一个接受 <code>Ping</code> 消息并以 ping 处理后的数字作为响应的参与者。</p>
<p>参与者（actor）是实现 <code>Actor</code> trait 的类型：</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

struct MyActor {
    count: usize,
}

impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;
}
#
# fn main() {}
</code></pre></pre>
<p>每个参与者都有一个执行上下文，对于 <code>MyActor</code> 我们会使用 <code>Context&lt;A&gt;</code>。关于<!--
-->参与者上下文的更多信息在下一节中介绍。</p>
<p>现在需要定义参与者需要接受的消息（<code>Message</code>）。消息可以是实现
<code>Message</code> trait 的任何类型。</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

#[derive(Message)]
#[rtype(result = &quot;usize&quot;)]
struct Ping(usize);
#
# fn main() {}
</code></pre></pre>
<p><code>Message</code> trait 的主要目的是定义结果类型。<code>Ping</code> 消息定义了
<code>usize</code>，表示任何可以接受 <code>Ping</code> 消息的参与者都需要<!--
-->返回 <code>usize</code> 值。</p>
<p>最后，需要声明我们的参与者 <code>MyActor</code> 可以接受 <code>Ping</code> 并处理它。
为此，该参与者需要实现 <code>Handler&lt;Ping&gt;</code> trait。</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# use actix::prelude::*;
#
# struct MyActor {
#    count: usize,
# }
# impl Actor for MyActor {
#     type Context = Context&lt;Self&gt;;
# }
#
# struct Ping(usize);
#
# impl Message for Ping {
#    type Result = usize;
# }
#
impl Handler&lt;Ping&gt; for MyActor {
    type Result = usize;

    fn handle(&amp;mut self, msg: Ping, _ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        self.count += msg.0;

        self.count
    }
}
#
# fn main() {}
</code></pre></pre>
<p>就是这样。现在只需要启动我们的参与者并向其发送消息。
启动过程取决于参与者的上下文实现。在本例中我们可以使用<!--
-->基于 tokio/future 的 <code>Context&lt;A&gt;</code>。可以用 <code>Actor::start()</code>
或者 <code>Actor::create()</code> 来启动。前者用于可以立即创建参与者实例的场景。
后者用于在创建参与者实例之前需要访问上下文对象的场景<!--
-->。对于 <code>MyActor</code> 参与者，我们可以使用 <code>start()</code>。</p>
<p>所有与参与者的通信都通过地址进行。可以用 <code>do_send</code> 发送一条消息<!--
-->而不等待响应，也可以向一个参与者用 <code>send</code> 发送指定消息。
<code>start()</code> 与 <code>create()</code> 都会返回一个地址对象。</p>
<p>在以下示例中，我们会创建一个 <code>MyActor</code> 参与者并发送一条消息。</p>
<p>Here we use the actix-rt as way to start our System and drive our main Future
so we can easily <code>.await</code> for the messages sent to the Actor.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate actix_rt;
# use actix::prelude::*;
# struct MyActor {
#    count: usize,
# }
# impl Actor for MyActor {
#     type Context = Context&lt;Self&gt;;
# }
#
# struct Ping(usize);
#
# impl Message for Ping {
#    type Result = usize;
# }
# impl Handler&lt;Ping&gt; for MyActor {
#     type Result = usize;
#
#     fn handle(&amp;mut self, msg: Ping, ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
#         self.count += msg.0;
#         self.count
#     }
# }
#
#[actix_rt::main] 
async fn main() {
    // 启动新的参与者
    let addr = MyActor { count: 10 }.start();

    // 发送消息并获取结果 future
    let res = addr.send(Ping(10)).await;

    // handle() returns tokio handle
    println!(&quot;RESULT: {}&quot;, res.unwrap() == 20);

    // stop system and exit
    System::current().stop();
}
</code></pre></pre>
<p><code>#[actix_rt::main]</code> starts the system and block until future resolves.</p>
<p>Ping 示例可在<a href="https://github.com/actix/actix/tree/master/examples/">示例目录</a>中找到。</p>
<a class="header" href="print.html#a参与者" id="a参与者"><h1>参与者</h1></a>
<p>Actix 是一个 rust 库，为开发并发应用程序提供了框架。</p>
<p>Actix 建立在<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E8%88%87%E8%80%85%E6%A8%A1%E5%BC%8F">参与者模型（Actor model）</a>之上，它<!--
-->使应用程序可以编写为一组独立执行而又相互协作的
“参与者”，这些参与者通过消息进行通信。参与者是封装<!--
-->状态与行为并且会在由 actix 库提供的 <em>Actor System</em> 中运行的对象。</p>
<p>参与者在指定的上下文 <a href="./sec-4-context.html"><code>Context&lt;A&gt;</code></a> 中运行。
该上下文对象只在执行期间可用。每个参与者都有一个独立的<!--
-->执行上下文。该执行上下文还控制参与者的生命周期。</p>
<p>参与者仅通过交换消息进行通信。发送方参与者可以<!--
-->选择等待该响应。不能直接引用参与者，而要通过<!--
-->地址来引用。</p>
<p>任何 rust 类型都可以是一个参与者，只需实现 <a href="https://actix.rs/actix/actix/trait.Actor.html"><code>Actor</code></a> trait 即可。</p>
<p>为了能够处理指定消息，参与者必须提供<!--
-->这种消息的 <a href="https://actix.rs/actix/actix/trait.Handler.html"><code>Handler&lt;M&gt;</code></a> 实现。所有消息<!--
-->都是静态类型的。可以使用异步方式处理消息。
参与者可以产生其他参与者或者将 future 或 stream 添加到执行上下文。
<code>Actor</code> trait 提供了几种可以控制参与者生命周期的方法。</p>
<a class="header" href="print.html#a参与者生命周期" id="a参与者生命周期"><h2>参与者生命周期</h2></a>
<a class="header" href="print.html#a已启动started" id="a已启动started"><h3>已启动（Started）</h3></a>
<p>参与者总是以 <code>Started</code> 状态启动。在这一状态期间调用了该参与者的 <code>started()</code>
方法。<code>Actor</code> trait 为这个方法提供了默认实现。
在这一状态期间可以使用参与者上下文，并且该参与者可以启动更多参与者或者注册<!--
-->异步流或者做任何其他所需的配置操作。</p>
<a class="header" href="print.html#a运行中running" id="a运行中running"><h3>运行中（Running）</h3></a>
<p>调用参与者的 <code>started()</code> 方法后，该参与者会转换为 <code>Running</code> 状态。
参与者可以无限期地处于 <code>running</code> 状态。</p>
<a class="header" href="print.html#a停止中stopping" id="a停止中stopping"><h3>停止中（Stopping）</h3></a>
<p>在以下情况下，参与者的执行状态会变更为 <code>stopping</code> 状态：</p>
<ul>
<li>该参与者自身调用了 <code>Context::stop</code></li>
<li>该参与者的所有地址都已删除。即没有其他参与者引用它。</li>
<li>在上下文中没有注册事件对象。</li>
</ul>
<p>一个参与者可以由 <code>stopping</code> 状态恢复为 <code>running</code> 状态，通过创建一个新的<!--
-->地址或者添加事件对象，以及通过返回 <code>Running::Continue</code> 实现。</p>
<p>如果一个参与者状态变更为 <code>stopping</code> 是因为调用了 <code>Context::stop()</code>，
那么该上下文会立即停止处理接入的消息，并调用
<code>Actor::stopping()</code>。如果参与者没有恢复到 <code>running</code> 状态，那么<!--
-->删除所有未处理的消息。</p>
<p>默认这个方法返回 <code>Running::Stop</code>，确认停止操作。</p>
<a class="header" href="print.html#a已停止stopped" id="a已停止stopped"><h3>已停止（Stopped）</h3></a>
<p>如果参与者在停止中状态期间没有修改执行上下文，那么参与者状态会变更<!--
-->为 <code>Stopped</code>。这个状态被认为是最终状态，此时该参与者会被 drop。</p>
<a class="header" href="print.html#a消息" id="a消息"><h2>消息</h2></a>
<p>一个 Actor 通过发送消息与其他参与者通信。在 actix 中的所有<!--
-->消息都是类型化的。消息可以是任何实现了
<a href="https://actix.rs/actix/actix/trait.Message.html"><code>Message</code></a> trait 的 rust 类型。<code>Message::Result</code> 定义了其返回值类型。
让我们来定义一个简单的 <code>Ping</code> 消息——接受这种消息的参与者需要返回
<code>Result&lt;bool, std::io::Error&gt;</code>。</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

struct Ping;

impl Message for Ping {
    type Result = Result&lt;bool, std::io::Error&gt;;
}
#
# fn main() {}
</code></pre></pre>
<a class="header" href="print.html#a产生一个参与者" id="a产生一个参与者"><h2>产生一个参与者</h2></a>
<p>如何启动一个参与者取决于它的上下文。可通过
<a href="https://actix.rs/actix/actix/trait.Actor.html"><code>Actor</code></a> trait 的
<code>start</code> 与 <code>create</code> 实现产生一个新的异步参与者。Actor trait 提供了几种不同的<!--
-->创建参与者的方式；更详细信息请查看其文档。</p>
<a class="header" href="print.html#a完整示例" id="a完整示例"><h2>完整示例</h2></a>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate actix_rt;
use actix::prelude::*;

/// 定义消息
#[derive(Message)]
#[rtype(result = &quot;Result&lt;bool, std::io::Error&gt;&quot;)]
struct Ping;

// 定义参与者
struct MyActor;

// 为我们的参与者提供 Actor 实现
impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;

    fn started(&amp;mut self, ctx: &amp;mut Context&lt;Self&gt;) {
       println!(&quot;Actor is alive&quot;);
    }

    fn stopped(&amp;mut self, ctx: &amp;mut Context&lt;Self&gt;) {
       println!(&quot;Actor is stopped&quot;);
    }
}

/// 为 `Ping` 消息定义处理程序
impl Handler&lt;Ping&gt; for MyActor {
    type Result = Result&lt;bool, std::io::Error&gt;;

    fn handle(&amp;mut self, msg: Ping, ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        println!(&quot;Ping received&quot;);

        Ok(true)
    }
}

#[actix_rt::main]
async fn main() {
    // 在当前线程启动 MyActor
    let addr = MyActor.start();

    // 发送 Ping 消息。
    // send() 消息返回 Future 对象，可解析出消息结果
    let result = addr.send(Ping).await;

    match result {
        Ok(res) =&gt; println!(&quot;Got result: {}&quot;, res.unwrap()),
        Err(err) =&gt; println!(&quot;Got error: {}&quot;, err),
    } 
}
</code></pre></pre>
<a class="header" href="print.html#a以-messageresponse-进行响应" id="a以-messageresponse-进行响应"><h2>以 MessageResponse 进行响应</h2></a>
<p>我们来看看上例中为 <code>impl Handler</code> 定义的 <code>Result</code> 类型。
看下我们是如何返回一个 <code>Result&lt;bool, std::io::Error&gt;</code> 的？我们能够以这种类型响应该参与者的<!--
-->接入消息，是因为它已经为该类型实现了 <code>MessageResponse</code> trait。
这是该 trait 的定义：</p>
<pre><code class="language-rust ignore">pub trait MessageResponse&lt;A: Actor, M: Message&gt; {
    fn handle&lt;R: ResponseChannel&lt;M&gt;&gt;(self, ctx: &amp;mut A::Context, tx: Option&lt;R&gt;);
}
</code></pre>
<p>有时会需要以没有为其实现这个 trait
的类型来响应接入的消息。当出现这种情况时，我们可以自己实现该 trait。
以下是一个示例，其中我们以 <code>GotPing</code> 响应 <code>Ping</code> 消息、
以 <code>GotPong</code> 响应 <code>Pong</code> 消息。</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate actix_rt;
use actix::dev::{MessageResponse, ResponseChannel};
use actix::prelude::*;

#[derive(Message)]
#[rtype(result = &quot;Responses&quot;)]
enum Messages {
    Ping,
    Pong,
}

enum Responses {
    GotPing,
    GotPong,
}

impl&lt;A, M&gt; MessageResponse&lt;A, M&gt; for Responses
where
    A: Actor,
    M: Message&lt;Result = Responses&gt;,
{
    fn handle&lt;R: ResponseChannel&lt;M&gt;&gt;(self, _: &amp;mut A::Context, tx: Option&lt;R&gt;) {
        if let Some(tx) = tx {
            tx.send(self);
        }
    }
}

// 定义参与者
struct MyActor;

// 为我们的参与者提供 Actor 实现
impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;

    fn started(&amp;mut self, _ctx: &amp;mut Context&lt;Self&gt;) {
        println!(&quot;Actor is alive&quot;);
    }

    fn stopped(&amp;mut self, _ctx: &amp;mut Context&lt;Self&gt;) {
        println!(&quot;Actor is stopped&quot;);
    }
}

/// 为 `Messages` 枚举定义处理程序
impl Handler&lt;Messages&gt; for MyActor {
    type Result = Responses;

    fn handle(&amp;mut self, msg: Messages, _ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        match msg {
            Messages::Ping =&gt; Responses::GotPing,
            Messages::Pong =&gt; Responses::GotPong,
        }
    }
}

#[actix_rt::main]
async fn main() {
    // 在当前线程启动 MyActor
    let addr = MyActor.start();

    // 发送 Ping 消息。
    // send() 消息返回 Future 对象，可解析出消息结果
    let ping_future = addr.send(Messages::Ping).await;
    let pong_future = addr.send(Messages::Pong).await;

    match pong_future {
        Ok(res) =&gt; match res {
            Responses::GotPing =&gt; println!(&quot;Ping received&quot;),
            Responses::GotPong =&gt; println!(&quot;Pong received&quot;),
        },
        Err(e) =&gt; println!(&quot;Actor is probably dead: {}&quot;, e),
    }

    match ping_future {
        Ok(res) =&gt; match res {
            Responses::GotPing =&gt; println!(&quot;Ping received&quot;),
            Responses::GotPong =&gt; println!(&quot;Pong received&quot;),
        },
        Err(e) =&gt; println!(&quot;Actor is probably dead: {}&quot;, e),
    }
}
</code></pre></pre>
<a class="header" href="print.html#a地址" id="a地址"><h1>地址</h1></a>
<p>参与者仅通过交换消息进行通信。发送方参与者可以选择<!--
-->等待该响应。不能直接引用参与者，只能通过其地址来引用。</p>
<p>有几种方式来获取参与者的地址。<code>Actor</code> trait 提供了<!--
-->两个辅助方法来启动参与者。这两个方法都会返回所启动参与者的地址。</p>
<p>以下是一个 <code>Actor::start()</code> 方法用法的示例。在这个示例中 <code>MyActor</code> 参与者是<!--
-->异步的，并且在与调用者相同的线程中启动——线程会在
<a href="./sec-6-sync-arbiter.md">SyncArbiter</a> 章节中介绍。</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# use actix::prelude::*;
#
struct MyActor;
impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;
}

# fn main() {
# System::new(&quot;test&quot;);
let addr = MyActor.start();
# }
</code></pre></pre>
<p>异步参与者可以由 <code>Context</code> 结构获取其地址。该上下文需要实现
<code>AsyncContext</code> trait。<code>AsyncContext::address()</code> 提供了参与者的地址。</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# use actix::prelude::*;
#
struct MyActor;

impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;

    fn started(&amp;mut self, ctx: &amp;mut Context&lt;Self&gt;) {
       let addr = ctx.address();
    }
}
#
# fn main() {}
</code></pre></pre>
<a class="header" href="print.html#a消息-1" id="a消息-1"><h2>消息</h2></a>
<p>为了能够处理指定消息，参与者必须提供<!--
-->这种消息的 <a href="https://actix.rs/actix/actix/trait.Handler.html"><code>Handler&lt;M&gt;</code></a> 实现。
所有消息都是静态类型的。可以使用异步方式处理消息<!--
-->。参与者可以产生其他参与者或者将 future 或
stream 添加到执行上下文。参与者 trait 提供了几种可以<!--
-->控制参与者生命周期的方法。</p>
<p>如需向参与者发送消息，需要使用 <code>Addr</code> 对象。<code>Addr</code> 提供了几种<!--
-->发送消息的方式。</p>
<ul>
<li>
<p><code>Addr::do_send(M)</code>——这个方法会忽略消息发送中的任何错误。如果信箱<!--
-->已满，那么仍会绕过限制将该消息排入队列。如果该参与者的信箱已关闭，
那么会以静默方式丢弃该消息。这个方法不会返回结果，因此<!--
-->信箱关闭及发生故障都无从知悉。</p>
</li>
<li>
<p><code>Addr::try_send(M)</code>——这个方法会立即尝试发送该消息。如果<!--
-->信箱已满或者关闭（参与者已死），那么这个方法返回
<a href="https://actix.rs/actix/actix/prelude/enum.SendError.html"><code>SendError</code></a>。</p>
</li>
<li>
<p><code>Addr::send(M)</code>——这个消息返回一个可解析出消息处理过程的<!--
-->结果的 future 对象。如果返回的 <code>Future</code> 对象被 drop，那么<!--
-->会取消该消息。</p>
</li>
</ul>
<a class="header" href="print.html#a收信方" id="a收信方"><h2>收信方</h2></a>
<p>收信方是仅支持一种类型消息的一种地址的专用版。
可以用于需要将消息发送给不同类型的参与者的场景。
可以用 <code>Addr::recipient()</code> 由地址创建收信方对象。</p>
<p>Address objects require an actor type, but if we just want to send a specific message
to an actor that can handle the message, we can use the Recipient interface.</p>
<p>例如，收信方可以用于订阅系统。在以下示例中，
<code>OrderEvents</code> 参与者向所有订阅者发送 <code>OrderShipped</code> 消息。订阅者可以<!--
-->是实现了 <code>Handler&lt;OrderShipped&gt;</code> trait 的任何参与者。</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

#[derive(Message)]
#[rtype(result = &quot;()&quot;)]
struct OrderShipped(usize);

#[derive(Message)]
#[rtype(result = &quot;()&quot;)]
struct Ship(usize);

/// Subscribe to order shipped event.
#[derive(Message)]
#[rtype(result = &quot;()&quot;)]
struct Subscribe(pub Recipient&lt;OrderShipped&gt;);

/// Actor that provides order shipped event subscriptions
struct OrderEvents {
    subscribers: Vec&lt;Recipient&lt;OrderShipped&gt;&gt;,
}

impl OrderEvents {
    fn new() -&gt; Self {
        OrderEvents {
            subscribers: vec![]
        }
    }
}

impl Actor for OrderEvents {
    type Context = Context&lt;Self&gt;;
}

impl OrderEvents {
    /// Send event to all subscribers
    fn notify(&amp;mut self, order_id: usize) {
        for subscr in &amp;self.subscribers {
           subscr.do_send(OrderShipped(order_id));
        }
    }
}

/// Subscribe to shipment event
impl Handler&lt;Subscribe&gt; for OrderEvents {
    type Result = ();

    fn handle(&amp;mut self, msg: Subscribe, _: &amp;mut Self::Context) {
        self.subscribers.push(msg.0);
    }
}

/// Subscribe to ship message
impl Handler&lt;Ship&gt; for OrderEvents {
    type Result = ();
    fn handle(&amp;mut self, msg: Ship, ctx: &amp;mut Self::Context) -&gt; Self::Result {
        self.notify(msg.0);
        System::current().stop();
    }

} 

/// Email Subscriber 
struct EmailSubscriber;
impl Actor for EmailSubscriber {
    type Context = Context&lt;Self&gt;;
}

impl Handler&lt;OrderShipped&gt; for EmailSubscriber {
    type Result = ();
    fn handle(&amp;mut self, msg: OrderShipped, _ctx: &amp;mut Self::Context) -&gt; Self::Result {
        println!(&quot;Email sent for order {}&quot;, msg.0)
    }
    
}
struct SmsSubscriber;
impl Actor for SmsSubscriber {
    type Context = Context&lt;Self&gt;;
}

impl Handler&lt;OrderShipped&gt; for SmsSubscriber {
    type Result = ();
    fn handle(&amp;mut self, msg: OrderShipped, _ctx: &amp;mut Self::Context) -&gt; Self::Result {
        println!(&quot;SMS sent for order {}&quot;, msg.0)
    }
    
}

fn main() {
    let system = System::new(&quot;events&quot;);
    let email_subscriber = Subscribe(EmailSubscriber{}.start().recipient());
    let sms_subscriber = Subscribe(SmsSubscriber{}.start().recipient());
    let order_event = OrderEvents::new().start();
    order_event.do_send(email_subscriber);
    order_event.do_send(sms_subscriber);
    order_event.do_send(Ship(1));
    system.run();
}
</code></pre></pre>
<a class="header" href="print.html#context" id="context"><h1>Context</h1></a>
<p>Actors all maintain an internal execution context, or state. This
allows an actor to determine its own Address, change mailbox limits,
or stop its execution.</p>
<a class="header" href="print.html#mailbox" id="mailbox"><h2>Mailbox</h2></a>
<p>All messages go to the actor's mailbox first, then the actor's execution context
calls specific message handlers. Mailboxes in general are bounded. The capacity is
specific to the context implementation. For the <code>Context</code>  type the capacity is set to
16 messages by default and can be increased with <a href="https://actix.rs/actix/actix/struct.Context.html#method.set_mailbox_capacity"><code>Context::set_mailbox_capacity()</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# use actix::prelude::*;
#
struct MyActor;

impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;

    fn started(&amp;mut self, ctx: &amp;mut Self::Context) {
        ctx.set_mailbox_capacity(1);
    }
}

# fn main() {
# System::new(&quot;test&quot;);
let addr = MyActor.start();
# }
</code></pre></pre>
<p>Remember that this doesn't apply to <code>Addr::do_send(M)</code> which bypasses the Mailbox queue limit, or
<code>AsyncContext::notify(M)</code> and <code>AsyncContext::notify_later(M, Duration)</code> which bypasses the mailbox
entirely.</p>
<a class="header" href="print.html#getting-your-actors-address" id="getting-your-actors-address"><h2>Getting your actors Address</h2></a>
<p>An actor can view its own address from its context. Perhaps you want to requeue an event for
later, or you want to transform the message type. Maybe you want to respond with your address
to a message. If you want an actor to send a message to itself, have a look at
<code>AsyncContext::notify(M)</code> instead.</p>
<p>To get your address from the context you call <a href="https://actix.rs/actix/actix/struct.Context.html#method.address"><code>Context::address()</code></a>. An example is:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# use actix::prelude::*;
#
struct MyActor;

struct WhoAmI;

impl Message for WhoAmI {
    type Result = Result&lt;actix::Addr&lt;MyActor&gt;, ()&gt;;
}

impl Actor for MyActor {
    type Context = Context&lt;Self&gt;;
}

impl Handler&lt;WhoAmI&gt; for MyActor {
    type Result = Result&lt;actix::Addr&lt;MyActor&gt;, ()&gt;;

    fn handle(&amp;mut self, msg: WhoAmI, ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        Ok(ctx.address())
    }
}

# fn main() {
#     System::new(&quot;scratch&quot;);
#     let addr = MyActor.start();
let who_addr = addr.do_send(WhoAmI{});
# }
</code></pre></pre>
<a class="header" href="print.html#stopping-an-actor" id="stopping-an-actor"><h2>Stopping an Actor</h2></a>
<p>From within the actors execution context you can choose to stop the actor from processing
any future Mailbox messages. This could be in response to an error condition, or as part
of program shutdown. To do this you call <a href="https://actix.rs/actix/actix/struct.Context.html#method.stop"><code>Context::stop()</code></a>.</p>
<p>This is an adjusted Ping example that stops after 4 pings are received.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate actix_rt;
# use actix::prelude::*;
# struct MyActor {
#     count: usize,
# }
# impl Actor for MyActor {
#     type Context = Context&lt;Self&gt;;
# }
#
# #[derive(Message)]
# #[rtype(result = &quot;usize&quot;)]
# struct Ping(usize);
#
impl Handler&lt;Ping&gt; for MyActor {
    type Result = usize;

    fn handle(&amp;mut self, msg: Ping, ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        self.count += msg.0;

        if self.count &gt; 5 {
            println!(&quot;Shutting down ping receiver.&quot;);
            ctx.stop()
        }

        self.count
    }
}

#[actix_rt::main]
async fn main() {
    // start new actor
    let addr = MyActor { count: 10 }.start();

    // send message and get future for result
    let addr_2 = addr.clone();
    let res = addr.send(Ping(6)).await;

    match res {
        Ok(_) =&gt; assert!(addr_2.try_send(Ping(6)).is_err()),
        _ =&gt; {}
    }
}
</code></pre></pre>
<a class="header" href="print.html#arbiter" id="arbiter"><h1>Arbiter</h1></a>
<p><code>Arbiter</code>s provide an asynchronous execution context for <code>Actor</code>s, <code>functions</code> and <code>futures</code>. Where an
actor contains a <code>Context</code> that defines its Actor specific execution state,
Arbiters host the environment where an actor runs.</p>
<p>As a result Arbiters perform a number of functions. Most notably, they are able
to spawn a new OS thread, run an event loop, spawn tasks asynchronously on that
event loop, and act as helpers for asynchronous tasks.</p>
<a class="header" href="print.html#system-and-arbiter" id="system-and-arbiter"><h2>System and Arbiter</h2></a>
<p>In all our previous code examples the function <code>System::new</code> creates an Arbiter
for your actors to run inside. When you call <code>start()</code> on your actor it is then
running inside of the System Arbiter's thread. In many cases, this is all you
will need for a program using Actix.</p>
<p>While it only uses one thread, it uses the very efficient event loop pattern
which works well for asynchronous events. To handle synchronous, CPU-bound
tasks, it's better to avoid blocking the event loop and instead offload the
computation to other threads. For this usecase, read the next section and
consider using <a href="./sec-6-sync-arbiter.md"><code>SyncArbiter</code></a>.</p>
<a class="header" href="print.html#the-event-loop" id="the-event-loop"><h2>The event loop</h2></a>
<p>One <code>Arbiter</code> is in control of one thread with one event pool. When an Arbiter
spawns a task (via <code>Arbiter::spawn</code>, <code>Context&lt;Actor&gt;::run_later</code>, or similar
constructs), the Arbiter queues the task for execution on that task queue. When
you think <code>Arbiter</code>, you can think &quot;single-threaded event loop&quot;.</p>
<p>Actix in general does support concurrency, but normal <code>Arbiter</code>s (not
<code>SyncArbiter</code>s) do not. To use Actix in a concurrent way, you can spin up
multiple <code>Arbiter</code>s using <code>Arbiter::new</code>, <code>ArbiterBuilder</code>, or <code>Arbiter::start</code>.</p>
<p>When you create a new Arbiter, this creates a new execution context for Actors.
The new thread is available to add new Actors to it, but Actors cannot freely
move between Arbiters: they are tied to the Arbiter they were spawned in.
However, Actors on different Arbiters can still communicate with each other
using the normal <code>Addr</code>/<code>Recipient</code> methods. The method of passing messages is
agnostic to whether the Actors are running on the same or different Arbiters.</p>
<a class="header" href="print.html#using-arbiter-for-resolving-async-events" id="using-arbiter-for-resolving-async-events"><h2>Using Arbiter for resolving async events</h2></a>
<p>If you aren't an expert in Rust Futures, Arbiter can be a helpful and simple
wrapper to resolving async events in order. Consider we have two actors, A and
B, and we want to run an event on B only once a result from A is completed. We
can use <code>Arbiter::spawn</code> to assist with this task.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

struct SumActor {}

impl Actor for SumActor {
    type Context = Context&lt;Self&gt;;
}

#[derive(Message)]
#[rtype(result = &quot;usize&quot;)]
struct Value(usize, usize);

impl Handler&lt;Value&gt; for SumActor {
    type Result = usize;

    fn handle(&amp;mut self, msg: Value, _ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        msg.0 + msg.1
    }
}

struct DisplayActor {}

impl Actor for DisplayActor {
    type Context = Context&lt;Self&gt;;
}

#[derive(Message)]
#[rtype(result = &quot;()&quot;)]
struct Display(usize);

impl Handler&lt;Display&gt; for DisplayActor {
    type Result = ();

    fn handle(&amp;mut self, msg: Display, _ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {
        println!(&quot;Got {:?}&quot;, msg.0);
    }
}

fn main() {
    let system = System::new(&quot;single-arbiter-example&quot;);

    // Define an execution flow using futures
    let execution = async {
        // `Actor::start` spawns the `Actor` on the *current* `Arbiter`, which
        // in this case is the System arbiter
        let sum_addr = SumActor {}.start();
        let dis_addr = DisplayActor {}.start();

        // Start by sending a `Value(6, 7)` to our `SumActor`.
        // `Addr::send` responds with a `Request`, which implements `Future`.
        // When awaited, it will resolve to a `Result&lt;usize, MailboxError&gt;`.
        let sum_result = sum_addr.send(Value(6, 7)).await;

        match sum_result {
            Ok(res) =&gt; {
                // `res` is now the `usize` returned from `SumActor` as a response to `Value(6, 7)`
                // Once the future is complete, send the successful response (`usize`)
                // to the `DisplayActor` wrapped in a `Display
                dis_addr.send(Display(res)).await;
            }
            Err(e) =&gt; {
                eprintln!(&quot;Encountered mailbox error: {:?}&quot;, e);
            }
        };
    };

    // Spawn the future onto the current Arbiter/event loop
    Arbiter::spawn(execution);

    // We only want to do one computation in this example, so we
    // shut down the `System` which will stop any Arbiters within
    // it (including the System Arbiter), which will in turn stop
    // any Actor Contexts running within those Arbiters, finally
    // shutting down all Actors.
    System::current().stop();

    system.run();
}
</code></pre></pre>
<a class="header" href="print.html#syncarbiter" id="syncarbiter"><h1>SyncArbiter</h1></a>
<p>When you normally run Actors, there are multiple Actors running on the
System's Arbiter thread, using its event loop. However for CPU bound workloads,
or highly concurrent workloads, you may wish to have an Actor running multiple
instances in parallel.</p>
<p>This is what a SyncArbiter provides - the ability to launch multiple instances of
an Actor on a pool of OS threads.</p>
<p>It's important to note a SyncArbiter can only host a single type of Actor. This means
you need to create a SyncArbiter for each type of Actor you want to run in this
manner.</p>
<a class="header" href="print.html#creating-a-sync-actor" id="creating-a-sync-actor"><h2>Creating a Sync Actor</h2></a>
<p>When implementing your Actor to be run on a SyncArbiter, it requires that your Actor's
Context is changed from <code>Context</code> to <code>SyncContext</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

struct MySyncActor;

impl Actor for MySyncActor {
    type Context = SyncContext&lt;Self&gt;;
}
#
# fn main() {
# System::new(&quot;test&quot;);
# }
</code></pre></pre>
<a class="header" href="print.html#starting-the-sync-arbiter" id="starting-the-sync-arbiter"><h2>Starting the Sync Arbiter</h2></a>
<p>Now that we have defined a Sync Actor, we can run it on a thread pool, created by
our <code>SyncArbiter</code>. We can only control the number of threads at SyncArbiter creation
time - we can't add/remove threads later.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
use actix::prelude::*;

struct MySyncActor;

impl Actor for MySyncActor {
    type Context = SyncContext&lt;Self&gt;;
}

# fn main() {
# System::new(&quot;test&quot;);
let addr = SyncArbiter::start(2, || MySyncActor);
# }
</code></pre></pre>
<p>We can communicate with the addr the same way as we have with our previous Actors
that we started. We can send messages, receive futures and results, and more.</p>
<a class="header" href="print.html#sync-actor-mailboxes" id="sync-actor-mailboxes"><h2>Sync Actor Mailboxes</h2></a>
<p>Sync Actors have no Mailbox limits, but you should still use <code>do_send</code>, <code>try_send</code> and <code>send</code>
as normal to account for other possible errors or sync vs async behavior.</p>
<p><strong>WIP</strong> </p>
<p><strong>WIP</strong> </p>
<p><strong>WIP</strong> </p>
<p><strong>WIP</strong> </p>
<p><strong>WIP</strong> </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-123031709-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
